###############################################################################
#                                                                             #
# IAR C/C++ Compiler V6.12.1.50500 for Atmel AVR        11/Feb/2015  02:09:26 #
# Copyright 1996-2012 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  G:\Work\Projects\ATMEL\IAR\C\MENU_TEMPLATE\char_display. #
#                    c                                                        #
#    Command line =  --string_literals_in_flash G:\Work\Projects\ATMEL\IAR\C\ #
#                    MENU_TEMPLATE\char_display.c --cpu=m32a -ms -o           #
#                    G:\Work\Projects\ATMEL\IAR\C\MENU_TEMPLATE\Debug\Obj\    #
#                    -lCN G:\Work\Projects\ATMEL\IAR\C\MENU_TEMPLATE\Debug\Li #
#                    st\ --initializers_in_flash --debug                      #
#                    -DENABLE_BIT_DEFINITIONS -e --eeprom_size 1024 --clib    #
#                    -Ohz                                                     #
#    List file    =  G:\Work\Projects\ATMEL\IAR\C\MENU_TEMPLATE\Debug\List\ch #
#                    ar_display.lst                                           #
#    Object file  =  G:\Work\Projects\ATMEL\IAR\C\MENU_TEMPLATE\Debug\Obj\cha #
#                    r_display.r90                                            #
#                                                                             #
#                                                                             #
###############################################################################

G:\Work\Projects\ATMEL\IAR\C\MENU_TEMPLATE\char_display.c
      1          //========================================================================
      2          #include "char_display.h"

   \                                 In  segment ABSOLUTE, at 0x3a
   \   union <unnamed> volatile __io _A_DDRA
   \                     _A_DDRA:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x3b
   \   union <unnamed> volatile __io _A_PORTA
   \                     _A_PORTA:
   \   00000000                      DS8 1
      3          //========================================================================
      4          
      5          //========================================================================

   \                                 In  segment CODE, align 2, keep-with-next
      6          void lcd_io_in (void)
   \                     lcd_io_in:
      7          {
      8             DATA_DDR = DATA_DDR & 0x0F;
   \   00000000   B30A               IN      R16, 0x1A
   \   00000002   700F               ANDI    R16, 0x0F
   \   00000004   BB0A               OUT     0x1A, R16
      9             DATA_PORT = DATA_PORT & 0x0F;
   \   00000006   B30B               IN      R16, 0x1B
   \   00000008   700F               ANDI    R16, 0x0F
   \   0000000A   BB0B               OUT     0x1B, R16
     10          }
   \   0000000C   9508               RET
   \   0000000E                      REQUIRE _A_DDRA
   \   0000000E                      REQUIRE _A_PORTA
     11          //------------------------------------------------------------------------
     12          
     13          //------------------------------------------------------------------------

   \                                 In  segment CODE, align 2, keep-with-next
     14          void lcd_send_nibble (u08 lcd_data)
   \                     lcd_send_nibble:
     15          {
     16             set_bit (CMD_PORT, EN);
   \   00000000   9ADA               SBI     0x1B, 0x02
     17             DATA_PORT = (DATA_PORT & 0x0F) | (lcd_data & 0xF0);
   \   00000002   B31B               IN      R17, 0x1B
   \   00000004   701F               ANDI    R17, 0x0F
   \   00000006   7F00               ANDI    R16, 0xF0
   \   00000008   2B10               OR      R17, R16
   \   0000000A   BB1B               OUT     0x1B, R17
     18             asm("nop");
   \   0000000C   0000               nop
     19             asm("nop");
   \   0000000E   0000               nop
     20             asm("nop");
   \   00000010   0000               nop
     21             asm("nop");
   \   00000012   0000               nop
     22             asm("nop");
   \   00000014   0000               nop
     23             asm("nop");
   \   00000016   0000               nop
     24             asm("nop");
   \   00000018   0000               nop
     25             asm("nop");
   \   0000001A   0000               nop
     26             asm("nop");
   \   0000001C   0000               nop
     27             asm("nop");
   \   0000001E   0000               nop
     28             clr_bit (CMD_PORT, EN);
   \   00000020   98DA               CBI     0x1B, 0x02
     29             asm("nop");
   \   00000022   0000               nop
     30             asm("nop");
   \   00000024   0000               nop
     31             asm("nop");
   \   00000026   0000               nop
     32             asm("nop");
   \   00000028   0000               nop
     33             asm("nop");
   \   0000002A   0000               nop
     34             asm("nop");
   \   0000002C   0000               nop
     35             asm("nop");
   \   0000002E   0000               nop
     36             asm("nop");
   \   00000030   0000               nop
     37             asm("nop");
   \   00000032   0000               nop
     38             asm("nop");
   \   00000034   0000               nop
     39          }
   \   00000036   9508               RET
   \   00000038                      REQUIRE _A_PORTA
     40          //------------------------------------------------------------------------
     41          
     42          //------------------------------------------------------------------------

   \                                 In  segment CODE, align 2, keep-with-next
     43          void lcd_send_byte (u08 lcd_data)
   \                     lcd_send_byte:
     44          {
   \   00000000   938A               ST      -Y, R24
   \   00000002   2F80               MOV     R24, R16
     45             DATA_DDR = (DATA_DDR | 0xF0);
   \   00000004   B30A               IN      R16, 0x1A
   \   00000006   6F00               ORI     R16, 0xF0
   \   00000008   BB0A               OUT     0x1A, R16
     46             lcd_send_nibble (lcd_data);
   \   0000000A   ....               RCALL   ?Subroutine3
     47             lcd_send_nibble (lcd_data << 4);
   \                     ??CrossCallReturnLabel_11:
   \   0000000C   9582               SWAP    R24
   \   0000000E   7F80               ANDI    R24, 0xF0
   \   00000010   ....               RCALL   ?Subroutine3
     48          }
   \                     ??CrossCallReturnLabel_10:
   \   00000012   9189               LD      R24, Y+
   \   00000014   9508               RET
   \   00000016                      REQUIRE _A_DDRA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine3:
   \   00000000   2F08               MOV     R16, R24
   \   00000002   ....               RJMP    lcd_send_nibble
     49          //------------------------------------------------------------------------
     50          
     51          //------------------------------------------------------------------------

   \                                 In  segment CODE, align 2, keep-with-next
     52          void lcd_send_com_nibble (u08 lcd_data)
   \                     lcd_send_com_nibble:
     53          {
     54             clr_bit (CMD_PORT, RS);
   \   00000000   98DB               CBI     0x1B, 0x03
     55             DATA_DDR = (DATA_DDR | 0xF0);
   \   00000002   B31A               IN      R17, 0x1A
   \   00000004   6F10               ORI     R17, 0xF0
   \   00000006   BB1A               OUT     0x1A, R17
     56             lcd_send_nibble (lcd_data);
   \   00000008   ....               RCALL   lcd_send_nibble
     57             lcd_io_in ();
   \   0000000A   ....               RJMP    ??Subroutine9_0
   \   0000000C                      REQUIRE _A_PORTA
   \   0000000C                      REQUIRE _A_DDRA
     58          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine9_0:
   \   00000000   ....               RJMP    lcd_io_in
     59          //------------------------------------------------------------------------
     60          
     61          //------------------------------------------------------------------------

   \                                 In  segment CODE, align 2, keep-with-next
     62          void lcd_send_com (u08 lcd_data)
   \                     lcd_send_com:
     63          
     64          {
     65             clr_bit (CMD_PORT, RS);
   \   00000000   98DB               CBI     0x1B, 0x03
     66             lcd_send_byte (lcd_data);
   \   00000002                      REQUIRE ?Subroutine7
   \   00000002                      REQUIRE _A_PORTA
   \   00000002                      ;               // Fall through to label ?Subroutine7
     67             lcd_io_in ();
     68          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine7:
   \   00000000   ....               RCALL   lcd_send_byte
   \   00000002                      REQUIRE ??Subroutine9_0
   \   00000002                      ;               // Fall through to label ??Subroutine9_0
     69          //------------------------------------------------------------------------
     70          
     71          //------------------------------------------------------------------------

   \                                 In  segment CODE, align 2, keep-with-next
     72          void lcd_send_data (u08 lcd_data)
   \                     lcd_send_data:
     73          {
     74             set_bit (CMD_PORT,RS);
   \   00000000   9ADB               SBI     0x1B, 0x03
     75             if (lcd_data >= 0xC0)
   \   00000002   ....               RCALL   ?Subroutine0
     76             {
     77                lcd_data = table_rus_chars [lcd_data - 0xC0];
     78             }
     79             lcd_send_byte (lcd_data);
   \                     ??CrossCallReturnLabel_0:
   \   00000004   ....               RJMP    ?Subroutine7
   \   00000006                      REQUIRE _A_PORTA
     80             lcd_io_in ();
     81          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   3C00               CPI     R16, 192
   \   00000002   F028               BRCS    ??Subroutine0_0
   \   00000004   E0F0               LDI     R31, 0
   \   00000006   2FE0               MOV     R30, R16
   \   00000008   ....               SUBI    R30, LOW((-(table_rus_chars - 192) & 0xFFFF))
   \   0000000A   ....               SBCI    R31, HIGH((-(table_rus_chars - 192) & 0xFFFF))
   \   0000000C   9104               LPM     R16, Z
   \                     ??Subroutine0_0:
   \   0000000E   9508               RET
     82          //========================================================================
     83          
     84          //========================================================================
     85           // Инициализация дисплея.
     86          

   \                                 In  segment CODE, align 2, keep-with-next
     87          void char_dsp_init (void)
   \                     char_dsp_init:
     88          {
     89             set_bit (EN_DDR, EN);
   \   00000000   9AD2               SBI     0x1A, 0x02
     90             set_bit (RS_DDR, RS);
   \   00000002   9AD3               SBI     0x1A, 0x03
     91          
     92          #if (TYPE_DISPLAY == LCD)
     93             wait_20_ms ();
     94          
     95             lcd_send_com_nibble (0x30); // Установка 8-разрядного интерфейса.
     96             wait_5_ms ();
     97          
     98             lcd_send_com_nibble (0x30); // Установка 8-разрядного интерфейса.
     99             wait_5_ms ();
    100          
    101             lcd_send_com_nibble (0x30); // Установка 8-разрядного интерфейса.
    102             wait_5_ms ();
    103          
    104             lcd_send_com_nibble (0x20); // Установка 4-разрядного интерфейса.
    105             wait_50_us ();
    106          
    107             lcd_send_com (0x28); // 4-разрядный интерфейс. Двухстрочный режим.
    108             wait_50_us ();
    109          
    110           lcd_send_com(0x01); // Команда очистки дисплея.
    111             wait_5_ms ();
    112          
    113             lcd_send_com (0x06); // Инкремент счетчика адреса.
    114             wait_50_us ();
    115          
    116             lcd_send_com (0x0C); // Включение дисплея.
    117             wait_50_us ();
    118          
    119          #elif (TYPE_DISPLAY == VFD)
    120             lcd_send_com_nibble (0x30); // Установка 8-разрядного интерфейса.
   \   00000004   ....               RCALL   ?Subroutine1
    121          //   wait_5_ms ();
    122          
    123             lcd_send_com_nibble (0x30); // Установка 8-разрядного интерфейса.
   \                     ??CrossCallReturnLabel_4:
   \   00000006   ....               RCALL   ?Subroutine1
    124          //   wait_5_ms ();
    125          
    126             lcd_send_com_nibble (0x30); // Установка 8-разрядного интерфейса.
   \                     ??CrossCallReturnLabel_3:
   \   00000008   ....               RCALL   ?Subroutine1
    127          //   wait_5_ms ();
    128          
    129             lcd_send_com_nibble (0x20); // Установка 4-разрядного интерфейса.
   \                     ??CrossCallReturnLabel_2:
   \   0000000A   E200               LDI     R16, 32
   \   0000000C   ....               RCALL   lcd_send_com_nibble
    130          //   wait_50_us ();
    131          
    132             lcd_send_com (0x28 | 3); // 4-разрядный интерфейс. Двухстрочный режим. Яркость 25 %
   \   0000000E   E20B               LDI     R16, 43
   \   00000010   ....               RCALL   ?Subroutine2
    133          //   wait_50_us ();
    134          
    135          //   lcd_send_com(0x01); // Команда очистки дисплея.
    136          //   wait_5_ms ();
    137          
    138             lcd_send_com (0x06); // Инкремент счетчика адреса.
   \                     ??CrossCallReturnLabel_9:
   \   00000012   E006               LDI     R16, 6
   \   00000014   ....               RCALL   ?Subroutine2
    139          //   wait_50_us ();
    140          
    141             lcd_send_com (0x0C); // Включение дисплея.
   \                     ??CrossCallReturnLabel_8:
   \   00000016   E00C               LDI     R16, 12
   \   00000018   ....               RCALL   ?Subroutine2
    142          //   wait_50_us ();
    143          #endif
    144          
    145             def_users_chars (table_users_chars);
   \                     ??CrossCallReturnLabel_7:
   \   0000001A   ....               LDI     R16, LOW(table_users_chars)
   \   0000001C   ....               LDI     R17, (table_users_chars) >> 8
   \   0000001E   ....               RJMP    def_users_chars
   \   00000020                      REQUIRE _A_DDRA
    146          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   E300               LDI     R16, 48
   \   00000002   ....               RJMP    lcd_send_com_nibble

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine2:
   \   00000000   ....               RJMP    lcd_send_com
    147          //========================================================================
    148          
    149          //========================================================================
    150          #if (TYPE_DISPLAY == VFD)
    151          

   \                                 In  segment NEAR_F, align 1, keep-with-next
    152          extern u08 __flash table_users_chars [8 * QUANT_USERS_CHARS]  = // Таблица пользовательских символов.
   \                     table_users_chars:
   \   00000000   0400150E0E15       DC8 0, 4, 14, 21, 21, 14, 4, 4, 0, 16, 16, 16, 30, 17, 17, 30, 0, 8, 12
   \              040410001010
   \              111E1E110800
   \              0C          
   \   00000013   1F1E0C1E0008       DC8 30, 31, 30, 12, 8, 0, 2, 6, 15, 31, 15, 6, 2
   \              06021F0F060F
   \              02          
    153          {
    154          0x00, 0x04, 0x0E, 0x15, 0x15, 0x0E, 0x04, 0x04, // Ф
    155          0x00, 0x10, 0x10, 0x10, 0x1E, 0x11, 0x11, 0x1E, // Ь
    156          0x00, 0x08, 0x0C, 0x1E, 0x1F, 0x1E, 0x0C, 0x08,
    157          0x00, 0x02, 0x06, 0x0F, 0x1F, 0x0F, 0x06, 0x02,
    158          };
    159          

   \                                 In  segment CODE, align 2, keep-with-next
    160          void def_users_chars (u08 __flash *ptr)
   \                     def_users_chars:
    161          {
   \   00000000   ........           CALL    ?PROLOGUE4_L09
   \   00000004   01C8               MOVW    R25:R24, R17:R16
    162             lcd_send_com (1<<6);
   \   00000006   E400               LDI     R16, 64
   \   00000008   ....               RCALL   ?Subroutine2
    163          
    164             u08 a;
    165             u08 b;
    166          
    167             for (a = QUANT_USERS_CHARS; a > 0; a--)
   \                     ??CrossCallReturnLabel_6:
   \   0000000A   E0B4               LDI     R27, 4
    168             {
    169                for (b = 8; b > 0; b--)
   \                     ??def_users_chars_0:
   \   0000000C   E0A8               LDI     R26, 8
    170                {
    171                   lcd_send_data (*ptr);
   \                     ??def_users_chars_1:
   \   0000000E   01FC               MOVW    R31:R30, R25:R24
   \   00000010   9105               LPM     R16, Z+
   \   00000012   01CF               MOVW    R25:R24, R31:R30
   \   00000014   ....               RCALL   lcd_send_data
    172                   ptr++;
    173                }
   \   00000016   95AA               DEC     R26
   \   00000018   F7D1               BRNE    ??def_users_chars_1
    174             }
   \   0000001A   95BA               DEC     R27
   \   0000001C   F7B9               BRNE    ??def_users_chars_0
    175          }
   \   0000001E   E0E4               LDI     R30, 4
   \   00000020   ........           JMP     ?EPILOGUE_B4_L09
    176          //------------------------------------------------------------------------
    177          
    178          //------------------------------------------------------------------------

   \                                 In  segment NEAR_F, align 1, keep-with-next
    179          extern u08 __flash table_rus_chars [32] = // Таблица кириллицы. VFD поддерживает только
   \                     table_rus_chars:
   \   00000000   804192424581       DC8 65, 128, 66, 146, 129, 69, 130, 131, 132, 133, 75, 134, 77, 72, 79
   \              83828584864B
   \              484D4F      
   \   0000000F   508754430088       DC8 135, 80, 67, 84, 136, 0, 88, 137, 138, 139, 140, 141, 142, 1, 143
   \              89588B8A8D8C
   \              018E8F      
   \   0000001E   ADAC               DC8 172, 173
    180          // заглавные русские буквы. И не все. Ф и Ь в таблице пользовательских символов.
    181          {
    182          //АБВГДЕЖЗ
    183          0x41, 0x80, 0x42, 0x92, 0x81, 0x45, 0x82, 0x83,
    184          //ИЙКЛМНОП
    185          0x84, 0x85, 0x4B, 0x86, 0x4D, 0x48, 0x4F, 0x87,
    186          //РСТУФХЦЧ
    187          0x50, 0x43, 0x54, 0x88, 0x00, 0x58, 0x89, 0x8A,
    188          //ШЩЪЫЬЭЮЯ
    189          0x8B, 0x8C, 0x8D, 0x8E, 0x01, 0x8F, 0xAC, 0xAD,
    190          };
    191          
    192          /*
    193          #elif (TYPE_DISPLAY == LCD)
    194          void lcd_putc(unsigned char c) 
    195          {
    196              if ( c == 0xA8) {     //буква 'Ё'
    197                c = 0xA2; 
    198              }
    199              else if ( c ==0xB8) { //буква 'ё'
    200                c = 0xB5; 
    201              }
    202              else if ( c >= 0xC0 ) {
    203                c = lcd_codepage[ c - 0xC0 ];
    204              }
    205              lcd_write( c );
    206          }
    207           
    208          unsigned  char  lcd_codepage[]=
    209          {
    210            0x41,0xa0,0x42,0xa1,0xe0,0x45,0xa3,0xa4,
    211            0xa5,0xa6,0x4b,0xa7,0x4d,0x48,0x4f,0xa8,
    212            0x50,0x43,0x54,0xa9,0xaa,0x58,0xe1,0xab,
    213            0xac,0xe2,0xad,0xae,0x62,0xaf,0xb0,0xb1,
    214            0x61,0xb2,0xb3,0xb4,0xe3,0x65,0xb6,0xb7,
    215            0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0x6f,0xbe,
    216            0x70,0x63,0xbf,0x79,0xe4,0x78,0xe5,0xc0,
    217            0xc1,0xe6,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,
    218          };
    219          */
    220          
    221          #endif
    222          //========================================================================
    223          
    224          //========================================================================
    225          // Очистка буфера дисплея.
    226          

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
    227          u08 dsp_buf [POSITION_MAX_X * POSITION_MAX_Y];
   \                     dsp_buf:
   \   00000000                      DS8 80
    228          

   \                                 In  segment CODE, align 2, keep-with-next
    229          void clr_dsp_buf (void)
   \                     clr_dsp_buf:
    230          {
    231             u08 i;
    232          
    233             for (i = 0; i < POSITION_MAX_X * POSITION_MAX_Y; i++)
   \   00000000   E000               LDI     R16, 0
   \   00000002   E220               LDI     R18, 32
    234                dsp_buf [i] = 0x20;
   \                     ??clr_dsp_buf_0:
   \   00000004   ....               RCALL   ?Subroutine4
   \                     ??CrossCallReturnLabel_12:
   \   00000006   8320               ST      Z, R18
   \   00000008   9503               INC     R16
   \   0000000A   3500               CPI     R16, 80
   \   0000000C   F3D8               BRCS    ??clr_dsp_buf_0
    235          
    236             init_dsp_buf ();
   \   0000000E                      REQUIRE ?Subroutine8
   \   0000000E                      ;               // Fall through to label ?Subroutine8
    237          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine8:
   \   00000000   ....               RJMP    init_dsp_buf

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine4:
   \   00000000   E0F0               LDI     R31, 0
   \   00000002   2FE0               MOV     R30, R16
   \   00000004   ....               SUBI    R30, LOW((-(dsp_buf) & 0xFFFF))
   \   00000006   ....               SBCI    R31, (-(dsp_buf) & 0xFFFF) >> 8
   \   00000008   9508               RET
    238          //========================================================================
    239          
    240          //========================================================================
    241          // Очистка определенного участка буфера дисплея. Формат:
    242          // Номер строки, номер знакоместа, кол-во очищаемых знакомест.
    243          

   \                                 In  segment CODE, align 2, keep-with-next
    244          void _clr_string (u08 x, u08 n)
   \                     _clr_string:
    245          {
   \   00000000   E240               LDI     R20, 32
   \   00000002   C003               RJMP    ??_clr_string_0
    246             while (n--) dsp_buf [x++] = ' ';
   \                     ??_clr_string_1:
   \   00000004   ....               RCALL   ?Subroutine4
   \                     ??CrossCallReturnLabel_13:
   \   00000006   8340               ST      Z, R20
   \   00000008   9503               INC     R16
   \                     ??_clr_string_0:
   \   0000000A   2F21               MOV     R18, R17
   \   0000000C   951A               DEC     R17
   \   0000000E   2322               TST     R18
   \   00000010   F7C9               BRNE    ??_clr_string_1
    247          
    248             init_dsp_buf ();
   \   00000012   ....               RJMP    ?Subroutine8
    249          }
    250          //========================================================================
    251          
    252          //========================================================================
    253          // Переинициализация модуля вывода информации из буфера на дисплей.
    254          // Чтобы обновление дисплея началось заново.
    255          

   \                                 In  segment CODE, align 2, keep-with-next
    256          void init_dsp_buf (void)
   \                     init_dsp_buf:
    257          {
    258             position_x = POSITION_MAX_X;
   \   00000000   ....               LDI     R30, LOW(_drv_char_dsp)
   \   00000002   ....               LDI     R31, (_drv_char_dsp) >> 8
   \   00000004   E104               LDI     R16, 20
   \   00000006   8302               STD     Z+2, R16
    259             position_y = POSITION_MAX_Y;
   \   00000008   E004               LDI     R16, 4
   \   0000000A   8303               STD     Z+3, R16
    260             _drv_char_dsp = DRV_CHAR_DSP_INIT_2;
   \   0000000C   E001               LDI     R16, 1
   \   0000000E                      REQUIRE ?Subroutine6
   \   0000000E                      ;               // Fall through to label ?Subroutine6
    261          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine6:
   \   00000000   8300               ST      Z, R16
   \   00000002   9508               RET
    262          //========================================================================
    263          
    264          //========================================================================
    265          u08 _drv_char_dsp;
    266          static u08 next_state;
    267          

   \                                 In  segment NEAR_I, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_I>`
    268          static const u08 lines [4] = {0x80, 0xC0, 0x94, 0xD4};
   \                     lines:
   \   00000000                      DS8 4
   \   00000004                      REQUIRE `?<Initializer for lines>`

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
   \                     _drv_char_dsp:
   \   00000000                      DS8 1
   \   00000001                      DS8 1
    269          
    270          u08 position_x;
   \                     position_x:
   \   00000002                      DS8 1
    271          u08 position_y;
   \                     position_y:
   \   00000003                      DS8 1
    272          

   \                                 In  segment CODE, align 2, keep-with-next
    273          void drv_char_dsp (void)
   \                     drv_char_dsp:
    274          {
    275             u08 data;
    276          
    277             switch (_drv_char_dsp)
   \   00000000   9100....           LDS     R16, _drv_char_dsp
   \   00000004   2300               TST     R16
   \   00000006   F051               BREQ    ??drv_char_dsp_0
   \   00000008   950A               DEC     R16
   \   0000000A   F051               BREQ    ??drv_char_dsp_1
   \   0000000C   950A               DEC     R16
   \   0000000E   F409               BRNE    $+2+2
   \   00000010   C04A               RJMP    ??drv_char_dsp_2
   \   00000012   950A               DEC     R16
   \   00000014   F061               BREQ    ??drv_char_dsp_3
   \   00000016   950A               DEC     R16
   \   00000018   F0D9               BREQ    ??drv_char_dsp_4
   \   0000001A   C04E               RJMP    ??drv_char_dsp_5
    278             {
    279                case DRV_CHAR_DSP_INIT_1:
    280                   char_dsp_init ();
   \                     ??drv_char_dsp_0:
   \   0000001C   ....               RCALL   char_dsp_init
    281          
    282                   clr_dsp_buf ();
   \   0000001E   ....               RCALL   clr_dsp_buf
    283          
    284                case DRV_CHAR_DSP_INIT_2:
    285                   position_x = 0;
   \                     ??drv_char_dsp_1:
   \   00000020   E000               LDI     R16, 0
   \   00000022   9300....           STS     (_drv_char_dsp + 2), R16
    286                   position_y = 0;
   \   00000026   9300....           STS     (_drv_char_dsp + 3), R16
    287          
    288                   next_state = DRV_CHAR_DSP_SEND_ADDR;
   \   0000002A   E003               LDI     R16, 3
   \   0000002C   C00B               RJMP    ??drv_char_dsp_6
    289                   _drv_char_dsp = DRV_CHAR_DSP_SET_NEXT_STATE;
    290                   break;
    291          
    292                case DRV_CHAR_DSP_SEND_ADDR:
    293                   if (wait (ST_DRV_CHAR_DSP))
   \                     ??drv_char_dsp_3:
   \   0000002E   ....               RCALL   ?Subroutine5
   \                     ??CrossCallReturnLabel_14:
   \   00000030   F409               BRNE    $+2+2
   \   00000032   C045               RJMP    ??drv_char_dsp_7
    294                   {
    295                      lcd_send_com (lines [position_y]);
   \   00000034   91E0....           LDS     R30, (_drv_char_dsp + 3)
   \   00000038   E0F0               LDI     R31, 0
   \   0000003A   ....               SUBI    R30, LOW((-(lines) & 0xFFFF))
   \   0000003C   ....               SBCI    R31, (-(lines) & 0xFFFF) >> 8
   \   0000003E   8100               LD      R16, Z
   \   00000040   ....               RCALL   ?Subroutine2
    296          
    297                      next_state = DRV_CHAR_DSP_SEND_CHAR;
   \                     ??CrossCallReturnLabel_5:
   \   00000042   E004               LDI     R16, 4
   \                     ??drv_char_dsp_6:
   \   00000044   9300....           STS     (_drv_char_dsp + 1), R16
    298                      _drv_char_dsp = DRV_CHAR_DSP_SET_NEXT_STATE;
   \   00000048   E002               LDI     R16, 2
   \                     ??drv_char_dsp_8:
   \   0000004A   9300....           STS     _drv_char_dsp, R16
   \   0000004E   9508               RET
    299                   }
    300                   break;
    301          
    302                case DRV_CHAR_DSP_SEND_CHAR:
    303                   if (wait (ST_DRV_CHAR_DSP))
   \                     ??drv_char_dsp_4:
   \   00000050   ....               RCALL   ?Subroutine5
   \                     ??CrossCallReturnLabel_15:
   \   00000052   F4A9               BRNE    ??drv_char_dsp_9
   \   00000054   9508               RET
    304                   {
    305                      while (position_x < POSITION_MAX_X)
    306                      {
    307                         data = dsp_buf [(position_y * POSITION_MAX_X) + position_x];
   \                     ??drv_char_dsp_10:
   \   00000056   9140....           LDS     R20, (_drv_char_dsp + 3)
   \   0000005A   E050               LDI     R21, 0
   \   0000005C   E104               LDI     R16, 20
   \   0000005E   E010               LDI     R17, 0
   \   00000060   ........           CALL    ?S_EC_MUL_L02
   \   00000064   0F02               ADD     R16, R18
   \   00000066   1F15               ADC     R17, R21
   \   00000068   01F8               MOVW    R31:R30, R17:R16
   \   0000006A   ....               SUBI    R30, LOW((-(dsp_buf) & 0xFFFF))
   \   0000006C   ....               SBCI    R31, (-(dsp_buf) & 0xFFFF) >> 8
   \   0000006E   8100               LD      R16, Z
    308          
    309                         if (data >= 0xC0)
   \   00000070   ....               RCALL   ?Subroutine0
    310                         {
    311                            data = table_rus_chars [data - 0xC0];
    312                         }
    313          
    314                         lcd_send_data (data);
   \                     ??CrossCallReturnLabel_1:
   \   00000072   ....               RCALL   lcd_send_data
    315                         position_x++;
   \   00000074   ....               LDI     R30, LOW(_drv_char_dsp)
   \   00000076   ....               LDI     R31, (_drv_char_dsp) >> 8
   \   00000078   8102               LDD     R16, Z+2
   \   0000007A   9503               INC     R16
   \   0000007C   8302               STD     Z+2, R16
    316                      }
   \                     ??drv_char_dsp_9:
   \   0000007E   9120....           LDS     R18, (_drv_char_dsp + 2)
   \   00000082   3124               CPI     R18, 20
   \   00000084   F340               BRCS    ??drv_char_dsp_10
    317          
    318                      position_x = 0;
   \   00000086   E000               LDI     R16, 0
   \   00000088   9300....           STS     (_drv_char_dsp + 2), R16
    319                      position_y++;
   \   0000008C   ....               LDI     R30, LOW(_drv_char_dsp)
   \   0000008E   ....               LDI     R31, (_drv_char_dsp) >> 8
   \   00000090   8103               LDD     R16, Z+3
   \   00000092   9503               INC     R16
   \   00000094   8303               STD     Z+3, R16
    320          
    321                      if (position_y >= POSITION_MAX_Y)
   \   00000096   3004               CPI     R16, 4
   \   00000098   F010               BRCS    ??drv_char_dsp_11
    322                      {
    323                         position_y = 0;
   \   0000009A   E000               LDI     R16, 0
   \   0000009C   8303               STD     Z+3, R16
    324          
    325          //               char_dsp_init ();
    326                      }
    327          
    328                      next_state = DRV_CHAR_DSP_SEND_ADDR;
   \                     ??drv_char_dsp_11:
   \   0000009E   E003               LDI     R16, 3
   \   000000A0   8301               STD     Z+1, R16
    329                      _drv_char_dsp = DRV_CHAR_DSP_SET_NEXT_STATE;
   \   000000A2   E002               LDI     R16, 2
   \   000000A4   ....               RJMP    ?Subroutine6
    330                   }
    331                   break;
    332          
    333                case DRV_CHAR_DSP_SET_NEXT_STATE:
    334                   set_timer (ST_DRV_CHAR_DSP, NO_RERUN_TIMER, 1);
   \                     ??drv_char_dsp_2:
   \   000000A6   E021               LDI     R18, 1
   \   000000A8   E030               LDI     R19, 0
   \   000000AA   E010               LDI     R17, 0
   \   000000AC   E004               LDI     R16, 4
   \   000000AE   ........           CALL    set_timer
    335                   _drv_char_dsp = next_state;
   \   000000B2   9100....           LDS     R16, (_drv_char_dsp + 1)
   \   000000B6   CFC9               RJMP    ??drv_char_dsp_8
    336                   break;
    337          
    338                default:
    339                   _drv_char_dsp = DRV_CHAR_DSP_INIT_1;
   \                     ??drv_char_dsp_5:
   \   000000B8   E000               LDI     R16, 0
   \   000000BA   9300....           STS     _drv_char_dsp, R16
    340                   break;
    341             }
    342          }
   \                     ??drv_char_dsp_7:
   \   000000BE   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine5:
   \   00000000   E004               LDI     R16, 4
   \   00000002   ........           CALL    wait
   \   00000006   2300               TST     R16
   \   00000008   9508               RET

   \                                 In  segment NEAR_ID, align 1, keep-with-next
   \                     `?<Initializer for lines>`:
   \   00000000   C080D494           DC8 128, 192, 148, 212
    343          //========================================================================

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
       0      2  _clr_string
                   0 2 -> init_dsp_buf
       0      2  char_dsp_init
                   0 2 -> def_users_chars
                   0 2 -> lcd_send_com
                   0 2 -> lcd_send_com_nibble
       0      2  clr_dsp_buf
                   0 2 -> init_dsp_buf
       4      2  def_users_chars
                   4 2 -> lcd_send_com
                   4 2 -> lcd_send_data
       2      4  drv_char_dsp
                   2 2 -> char_dsp_init
                   2 2 -> clr_dsp_buf
                   2 2 -> lcd_send_com
                   2 2 -> lcd_send_data
                   2 2 -> set_timer
                   2 2 -> wait
       0      2  init_dsp_buf
       0      2  lcd_io_in
       1      2  lcd_send_byte
                   1 2 -> lcd_send_nibble
       0      2  lcd_send_com
                   0 2 -> lcd_io_in
                   0 2 -> lcd_send_byte
       0      2  lcd_send_com_nibble
                   0 2 -> lcd_io_in
                   0 2 -> lcd_send_nibble
       0      2  lcd_send_data
                   0 2 -> lcd_io_in
                   0 2 -> lcd_send_byte
       0      2  lcd_send_nibble


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       4  ?<Initializer for lines>
       2  ??Subroutine9_0
      16  ?Subroutine0
       4  ?Subroutine1
       2  ?Subroutine2
       4  ?Subroutine3
      10  ?Subroutine4
      10  ?Subroutine5
       4  ?Subroutine6
       2  ?Subroutine7
       2  ?Subroutine8
       1  _A_DDRA
       1  _A_PORTA
      20  _clr_string
       4  _drv_char_dsp
          next_state
          position_x
          position_y
      32  char_dsp_init
      14  clr_dsp_buf
      36  def_users_chars
     192  drv_char_dsp
      80  dsp_buf
      14  init_dsp_buf
      14  lcd_io_in
      22  lcd_send_byte
       2  lcd_send_com
      12  lcd_send_com_nibble
       6  lcd_send_data
      56  lcd_send_nibble
       4  lines
      32  table_rus_chars
      32  table_users_chars
      12  -- Other

 
   2 bytes in segment ABSOLUTE
 476 bytes in segment CODE
  12 bytes in segment INITTAB
  64 bytes in segment NEAR_F
   4 bytes in segment NEAR_I
   4 bytes in segment NEAR_ID
  84 bytes in segment NEAR_Z
 
 544 bytes of CODE memory (+ 12 bytes shared)
  88 bytes of DATA memory (+  2 bytes shared)

Errors: none
Warnings: none

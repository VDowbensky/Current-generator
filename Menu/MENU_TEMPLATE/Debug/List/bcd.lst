###############################################################################
#                                                                             #
# IAR C/C++ Compiler V6.12.1.50500 for Atmel AVR        11/Feb/2015  02:09:25 #
# Copyright 1996-2012 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  G:\Work\Projects\ATMEL\IAR\C\MENU_TEMPLATE\bcd.c         #
#    Command line =  --string_literals_in_flash G:\Work\Projects\ATMEL\IAR\C\ #
#                    MENU_TEMPLATE\bcd.c --cpu=m32a -ms -o                    #
#                    G:\Work\Projects\ATMEL\IAR\C\MENU_TEMPLATE\Debug\Obj\    #
#                    -lCN G:\Work\Projects\ATMEL\IAR\C\MENU_TEMPLATE\Debug\Li #
#                    st\ --initializers_in_flash --debug                      #
#                    -DENABLE_BIT_DEFINITIONS -e --eeprom_size 1024 --clib    #
#                    -Ohz                                                     #
#    List file    =  G:\Work\Projects\ATMEL\IAR\C\MENU_TEMPLATE\Debug\List\bc #
#                    d.lst                                                    #
#    Object file  =  G:\Work\Projects\ATMEL\IAR\C\MENU_TEMPLATE\Debug\Obj\bcd #
#                    .r90                                                     #
#                                                                             #
#                                                                             #
###############################################################################

G:\Work\Projects\ATMEL\IAR\C\MENU_TEMPLATE\bcd.c
      1          //========================================================================
      2          #include "bcd.h"
      3          //========================================================================
      4          
      5          //========================================================================

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
      6          char num_str_buf [11];
   \                     num_str_buf:
   \   00000000                      DS8 11

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
      7          char tmp_num_str_buf [11];
   \                     tmp_num_str_buf:
   \   00000000                      DS8 11
      8          //========================================================================
      9          
     10          //========================================================================

   \                                 In  segment CODE, align 2, keep-with-next
     11          void clr_tmp_num_str_buf (void)
   \                     clr_tmp_num_str_buf:
     12          {
     13             char *ptr = tmp_num_str_buf;
   \   00000000   ....               LDI     R30, LOW(tmp_num_str_buf)
   \   00000002   ....               LDI     R31, (tmp_num_str_buf) >> 8
     14             u08 cnt = 10;
   \   00000004   ....               RJMP    ?Subroutine0
     15          
     16             while (cnt)
     17             {
     18                *ptr++ = ' ';
     19                cnt--;
     20             }
     21             *ptr = 0;
     22          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   E00A               LDI     R16, 10
   \   00000002   E210               LDI     R17, 32
   \                     ??Subroutine0_0:
   \   00000004   9311               ST      Z+, R17
   \   00000006   950A               DEC     R16
   \   00000008   F7E9               BRNE    ??Subroutine0_0
   \   0000000A   E000               LDI     R16, 0
   \   0000000C   8300               ST      Z, R16
   \   0000000E   9508               RET
     23          //========================================================================
     24          
     25          //========================================================================

   \                                 In  segment CODE, align 2, keep-with-next
     26          void clr_num_str_buf (void)
   \                     clr_num_str_buf:
     27          {
     28             char *ptr = num_str_buf;
   \   00000000   ....               LDI     R30, LOW(num_str_buf)
   \   00000002   ....               LDI     R31, (num_str_buf) >> 8
     29             u08 cnt = 10;
   \   00000004                      REQUIRE ?Subroutine0
   \   00000004                      ;               // Fall through to label ?Subroutine0
     30          
     31             while (cnt)
     32             {
     33                *ptr++ = ' ';
     34                cnt--;
     35             }
     36             *ptr = 0;
     37          }
     38          //========================================================================
     39          
     40          //========================================================================

   \                                 In  segment NEAR_F, align 1, keep-with-next
     41          u16 __flash tab_10_16 [] =
   \                     tab_10_16:
   \   00000000   271003E80064       DC16 10000, 1000, 100, 10
   \              000A        
     42          {
     43             10000U,
     44             1000U,
     45             100U,
     46             10U,
     47          };
     48          //------------------------------------------------------------------------

   \                                 In  segment CODE, align 2, keep-with-next
     49          void int_to_str (u16 value)
   \                     int_to_str:
     50          {
   \   00000000   ....               RCALL   ?Subroutine2
   \                     ??CrossCallReturnLabel_3:
   \   00000002   01C8               MOVW    R25:R24, R17:R16
     51             clr_num_str_buf ();
   \   00000004   ....               RCALL   clr_num_str_buf
     52          
     53             char *ptr = num_str_buf + 5;
   \   00000006   ....               LDI     R26, LOW((num_str_buf + 5))
   \   00000008   ....               LDI     R27, HIGH((num_str_buf + 5))
     54          
     55             u16 a;
     56          
     57             u08 flags = 0;
   \   0000000A   E020               LDI     R18, 0
     58             u08 cnt_1;
     59             u08 cnt_2;
     60          
     61             u16 __flash *ptr_f = tab_10_16;
   \   0000000C   ....               LDI     R30, LOW(tab_10_16)
   \   0000000E   ....               LDI     R31, (tab_10_16) >> 8
     62          
     63             cnt_1 = 4;
   \   00000010   E004               LDI     R16, 4
     64          
     65             while (cnt_1)
     66             {
     67                a = *ptr_f;
   \                     ??int_to_str_0:
   \   00000012   9145               LPM     R20, Z+
   \   00000014   9155               LPM     R21, Z+
     68                cnt_2 = 0;
   \   00000016   E030               LDI     R19, 0
   \   00000018   C003               RJMP    ??int_to_str_1
     69          
     70                while (value >= a)
     71                {
     72                   value -= a;
   \                     ??int_to_str_2:
   \   0000001A   1B84               SUB     R24, R20
   \   0000001C   0B95               SBC     R25, R21
     73                   cnt_2++;
   \   0000001E   9533               INC     R19
     74                }
   \                     ??int_to_str_1:
   \   00000020   1784               CP      R24, R20
   \   00000022   0795               CPC     R25, R21
   \   00000024   F7D0               BRCC    ??int_to_str_2
     75          
     76                if (!(flags & (1<<0)))
   \   00000026   2F13               MOV     R17, R19
   \   00000028   6310               ORI     R17, 0x30
   \   0000002A   FB20               BST     R18, 0
   \   0000002C   F03E               BRTS    ??int_to_str_3
     77                {
     78                   if (cnt_2 == 0)
   \   0000002E   2333               TST     R19
   \   00000030   F411               BRNE    ??int_to_str_4
     79                   {
     80                      *ptr++ = ' '; // Гашение незначащих нулей.
   \   00000032   E210               LDI     R17, 32
   \   00000034   C003               RJMP    ??int_to_str_3
     81                   }
     82                   else
     83                   {
     84                      *ptr++ = (cnt_2 | 0x30);
   \                     ??int_to_str_4:
   \   00000036   931D               ST      X+, R17
     85                      set_bit (flags, 0);
   \   00000038   6021               ORI     R18, 0x01
   \   0000003A   C001               RJMP    ??int_to_str_5
     86                   }
     87                }
     88                else
     89                {
     90                   *ptr++ = (cnt_2 | 0x30);
   \                     ??int_to_str_3:
   \   0000003C   931D               ST      X+, R17
     91                }
     92          
     93                ptr_f++;
     94                cnt_1--;
   \                     ??int_to_str_5:
   \   0000003E   950A               DEC     R16
     95             }
   \   00000040   F741               BRNE    ??int_to_str_0
     96             *ptr++ = (value | 0x30);
   \   00000042   6380               ORI     R24, 0x30
   \   00000044   938D               ST      X+, R24
     97             *ptr = 0;
   \   00000046   E000               LDI     R16, 0
   \   00000048   930C               ST      X, R16
     98          }
   \   0000004A                      REQUIRE ?Subroutine3
   \   0000004A                      ;               // Fall through to label ?Subroutine3

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine3:
   \   00000000   E0E4               LDI     R30, 4
   \   00000002   ........           JMP     ?EPILOGUE_B4_L09

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine2:
   \   00000000   ........           JMP     ?PROLOGUE4_L09
     99          //========================================================================
    100          
    101          //========================================================================
    102          // Я пока в раздумьях, на какой реакции остановиться, если в строке нет чисел.
    103          // Можно сделать так: u16, u08 dec_hex_u16 (void). u08 0 - ошибка. 1 - ошибок нет.
    104          // Также можно сделать следующее. Если разрядность строки больше u16 - ошибка.
    105          

   \                                 In  segment CODE, align 2, keep-with-next
    106          u16 str_to_int (void)
   \                     str_to_int:
    107          {
   \   00000000   ....               RCALL   ?Subroutine2
    108             char *ptr_num = tmp_num_str_buf + 5;
   \                     ??CrossCallReturnLabel_4:
   \   00000002   ....               LDI     R26, LOW((tmp_num_str_buf + 5))
   \   00000004   ....               LDI     R27, HIGH((tmp_num_str_buf + 5))
    109             u16 __flash *ptr_tab_10 = tab_10_16;
   \   00000006   ....               LDI     R30, LOW(tab_10_16)
   \   00000008   ....               LDI     R31, (tab_10_16) >> 8
    110             u16 a;
    111             u08 cnt = 0;
    112             u16 tmp_value = 0;
   \   0000000A   E000               LDI     R16, 0
   \   0000000C   E010               LDI     R17, 0
   \   0000000E   E024               LDI     R18, 4
    113          
    114             while (cnt < 4)
    115             {
    116                if ((*ptr_num > 0x30) && (*ptr_num < 0x3A))
   \                     ??str_to_int_0:
   \   00000010   913C               LD      R19, X
   \   00000012   5331               SUBI    R19, 49
   \   00000014   3039               CPI     R19, 9
   \   00000016   F458               BRCC    ??str_to_int_1
    117                {
    118                   a = (*ptr_num - 0x30);
   \   00000018   ....               RCALL   ?Subroutine1
   \                     ??CrossCallReturnLabel_0:
   \   0000001A   C006               RJMP    ??str_to_int_2
    119          
    120                   while (a)
    121                   {
    122                      tmp_value += *ptr_tab_10;
   \                     ??str_to_int_3:
   \   0000001C   9145               LPM     R20, Z+
   \   0000001E   9154               LPM     R21, Z
   \   00000020   9731               SBIW    R31:R30, 1
   \   00000022   0F04               ADD     R16, R20
   \   00000024   1F15               ADC     R17, R21
    123                      a--;
   \   00000026   9701               SBIW    R25:R24, 1
    124                   }
   \                     ??str_to_int_2:
   \   00000028   2F38               MOV     R19, R24
   \   0000002A   2B39               OR      R19, R25
   \   0000002C   F7B9               BRNE    ??str_to_int_3
    125                }
    126                *ptr_num++;
   \                     ??str_to_int_1:
   \   0000002E   9611               ADIW    R27:R26, 1
    127                ptr_tab_10++;
   \   00000030   9632               ADIW    R31:R30, 2
    128                cnt++;
   \   00000032   952A               DEC     R18
    129             }
   \   00000034   F769               BRNE    ??str_to_int_0
    130                return tmp_value += (*ptr_num - 0x30);
   \   00000036   ....               RCALL   ?Subroutine1
   \                     ??CrossCallReturnLabel_1:
   \   00000038   0F08               ADD     R16, R24
   \   0000003A   1F19               ADC     R17, R25
   \   0000003C   ....               RJMP    ?Subroutine3
    131          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   918C               LD      R24, X
   \   00000002   E090               LDI     R25, 0
   \   00000004   97C0               SBIW    R25:R24, 48
   \   00000006   9508               RET
    132          //========================================================================
    133          
    134          //========================================================================

   \                                 In  segment NEAR_F, align 1, keep-with-next
    135          u32 __flash tab_10_32 [] =
   \                     tab_10_32:
   \   00000000   CA003B9AE100       DD 1000000000, 100000000, 10000000, 1000000, 100000, 10000, 1000, 100
   \              05F596800098
   \              4240000F86A0
   \              000127100000
   \              03E800000064
   \              0000        
   \   00000020   000A0000           DD 10
    136          {
    137             1000000000U,
    138             100000000U,
    139             10000000U,
    140             1000000U,
    141             100000U,
    142             10000U,
    143             1000U,
    144             100U,
    145             10U,
    146          };
    147          //------------------------------------------------------------------------

   \                                 In  segment CODE, align 2, keep-with-next
    148          void long_to_str (u32 value)
   \                     long_to_str:
    149          {
   \   00000000   ....               RCALL   ?Subroutine2
   \                     ??CrossCallReturnLabel_5:
   \   00000002   01C8               MOVW    R25:R24, R17:R16
   \   00000004   01D9               MOVW    R27:R26, R19:R18
    150             clr_num_str_buf ();
   \   00000006   ....               RCALL   clr_num_str_buf
    151          
    152             char *ptr = num_str_buf;
   \   00000008   ....               LDI     R16, LOW(num_str_buf)
   \   0000000A   ....               LDI     R17, (num_str_buf) >> 8
    153          
    154             u32 a;
    155          
    156             u08 flags = 0;
   \   0000000C   2411               CLR     R1
    157             u08 cnt_1;
    158             u08 cnt_2;
    159          
    160             u32 __flash *ptr_f = tab_10_32;
   \   0000000E   ....               LDI     R18, LOW(tab_10_32)
   \   00000010   ....               LDI     R19, (tab_10_32) >> 8
    161          
    162             cnt_1 = 9;
   \   00000012   E049               LDI     R20, 9
   \   00000014   2E04               MOV     R0, R20
    163          
    164             while (cnt_1)
    165             {
    166                a = *ptr_f;
   \                     ??long_to_str_0:
   \   00000016   01F9               MOVW    R31:R30, R19:R18
   \   00000018   9145               LPM     R20, Z+
   \   0000001A   9155               LPM     R21, Z+
   \   0000001C   9165               LPM     R22, Z+
   \   0000001E   9174               LPM     R23, Z
    167                cnt_2 = 0;
   \   00000020   E0F0               LDI     R31, 0
   \   00000022   C005               RJMP    ??long_to_str_1
    168          
    169                while (value >=a)
    170                {
    171                   value -= a;
   \                     ??long_to_str_2:
   \   00000024   1B84               SUB     R24, R20
   \   00000026   0B95               SBC     R25, R21
   \   00000028   0BA6               SBC     R26, R22
   \   0000002A   0BB7               SBC     R27, R23
    172                   cnt_2++;
   \   0000002C   95F3               INC     R31
    173                }
   \                     ??long_to_str_1:
   \   0000002E   1784               CP      R24, R20
   \   00000030   0795               CPC     R25, R21
   \   00000032   07A6               CPC     R26, R22
   \   00000034   07B7               CPC     R27, R23
   \   00000036   F7B0               BRCC    ??long_to_str_2
    174          
    175                if (!(flags & (1<<0)))
   \   00000038   2F4F               MOV     R20, R31
   \   0000003A   6340               ORI     R20, 0x30
   \   0000003C   FA10               BST     R1, 0
   \   0000003E   F056               BRTS    ??long_to_str_3
    176                {
    177                   if (cnt_2 == 0)
   \   00000040   23FF               TST     R31
   \   00000042   F411               BRNE    ??long_to_str_4
    178                   {
    179                      *ptr++ = ' '; // Гашение незначащих нулей.
   \   00000044   E240               LDI     R20, 32
   \   00000046   C006               RJMP    ??long_to_str_3
    180                   }
    181                   else
    182                   {
    183                      *ptr++ = (cnt_2 | 0x30);
   \                     ??long_to_str_4:
   \   00000048   01F8               MOVW    R31:R30, R17:R16
   \   0000004A   9341               ST      Z+, R20
   \   0000004C   018F               MOVW    R17:R16, R31:R30
    184                      set_bit (flags, 0);
   \   0000004E   9468               SET
   \   00000050   F810               BLD     R1, 0
   \   00000052   C003               RJMP    ??long_to_str_5
    185                   }
    186                }
    187                else
    188                {
    189                   *ptr++ = (cnt_2 | 0x30);
   \                     ??long_to_str_3:
   \   00000054   01F8               MOVW    R31:R30, R17:R16
   \   00000056   9341               ST      Z+, R20
   \   00000058   018F               MOVW    R17:R16, R31:R30
    190                }
    191          
    192                ptr_f++;
   \                     ??long_to_str_5:
   \   0000005A   5F2C               SUBI    R18, 252
   \   0000005C   4F3F               SBCI    R19, 255
    193                cnt_1--;
   \   0000005E   940A               DEC     R0
    194             }
   \   00000060   F6D1               BRNE    ??long_to_str_0
    195             *ptr++ = (value | 0x30);
   \   00000062   6380               ORI     R24, 0x30
   \   00000064   8380               ST      Z, R24
    196             *ptr = 0;
   \   00000066   E020               LDI     R18, 0
   \   00000068   5F0F               SUBI    R16, 255
   \   0000006A   4F1F               SBCI    R17, 255
   \   0000006C   01F8               MOVW    R31:R30, R17:R16
   \   0000006E   8320               ST      Z, R18
    197          }
   \   00000070   ....               RJMP    ?Subroutine3
    198          //========================================================================
    199          
    200          //========================================================================
    201          // Я пока в раздумьях, на какой реакции остановиться, если в строке нет чисел.
    202          // Можно сделать так: u32, u08 dec_hex_u32 (void). u08 0 - ошибка. 1 - ошибок нет.
    203          // Также можно сделать следующее. Если разрядность строки больше u32 - ошибка.
    204          

   \                                 In  segment CODE, align 2, keep-with-next
    205          u32 str_to_long (void)
   \                     str_to_long:
    206          {
   \   00000000   ........           CALL    ?PROLOGUE8_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004                      REQUIRE ?Register_R6_is_cg_reg
   \   00000004                      REQUIRE ?Register_R7_is_cg_reg
    207             char *ptr_num = tmp_num_str_buf;
   \   00000004   ....               LDI     R26, LOW(tmp_num_str_buf)
   \   00000006   ....               LDI     R27, (tmp_num_str_buf) >> 8
    208             u32 __flash *ptr_tab_10 = tab_10_32;
   \   00000008   ....               LDI     R30, LOW(tab_10_32)
   \   0000000A   ....               LDI     R31, (tab_10_32) >> 8
    209             u32 a;
    210             u08 cnt = 0;
    211             u32 tmp_value = 0;
   \   0000000C   E040               LDI     R20, 0
   \   0000000E   E050               LDI     R21, 0
   \   00000010   E060               LDI     R22, 0
   \   00000012   E070               LDI     R23, 0
   \   00000014   E009               LDI     R16, 9
   \   00000016   2E00               MOV     R0, R16
    212          
    213             while (cnt < 9)
    214             {
    215                if ((*ptr_num > 0x30) && (*ptr_num < 0x3A))
   \                     ??str_to_long_0:
   \   00000018   910C               LD      R16, X
   \   0000001A   5301               SUBI    R16, 49
   \   0000001C   3009               CPI     R16, 9
   \   0000001E   F4D8               BRCC    ??str_to_long_1
    216                {
    217                   a = (*ptr_num - 0x30);
   \   00000020   910C               LD      R16, X
   \   00000022   E010               LDI     R17, 0
   \   00000024   5300               SUBI    R16, 48
   \   00000026   4010               SBCI    R17, 0
   \   00000028   2F21               MOV     R18, R17
   \   0000002A   0F22               LSL     R18
   \   0000002C   0B22               SBC     R18, R18
   \   0000002E   2F32               MOV     R19, R18
   \   00000030   C00D               RJMP    ??str_to_long_2
    218          
    219                   while (a)
    220                   {
    221                      tmp_value += *ptr_tab_10;
   \                     ??str_to_long_3:
   \   00000032   9045               LPM     R4, Z+
   \   00000034   9055               LPM     R5, Z+
   \   00000036   9065               LPM     R6, Z+
   \   00000038   9074               LPM     R7, Z
   \   0000003A   9733               SBIW    R31:R30, 3
   \   0000003C   0D44               ADD     R20, R4
   \   0000003E   1D55               ADC     R21, R5
   \   00000040   1D66               ADC     R22, R6
   \   00000042   1D77               ADC     R23, R7
    222                      a--;
   \   00000044   5001               SUBI    R16, 1
   \   00000046   4010               SBCI    R17, 0
   \   00000048   4020               SBCI    R18, 0
   \   0000004A   4030               SBCI    R19, 0
    223                   }
   \                     ??str_to_long_2:
   \   0000004C   2E10               MOV     R1, R16
   \   0000004E   2A11               OR      R1, R17
   \   00000050   2A12               OR      R1, R18
   \   00000052   2A13               OR      R1, R19
   \   00000054   F771               BRNE    ??str_to_long_3
    224                }
    225                *ptr_num++;
   \                     ??str_to_long_1:
   \   00000056   9611               ADIW    R27:R26, 1
    226                ptr_tab_10++;
   \   00000058   9634               ADIW    R31:R30, 4
    227                cnt++;
   \   0000005A   940A               DEC     R0
    228             }
   \   0000005C   F6E9               BRNE    ??str_to_long_0
    229                return tmp_value += (*ptr_num - 0x30);
   \   0000005E   018A               MOVW    R17:R16, R21:R20
   \   00000060   019B               MOVW    R19:R18, R23:R22
   \   00000062   ....               RCALL   ?Subroutine1
   \                     ??CrossCallReturnLabel_2:
   \   00000064   2FA9               MOV     R26, R25
   \   00000066   0FAA               LSL     R26
   \   00000068   0BAA               SBC     R26, R26
   \   0000006A   0F08               ADD     R16, R24
   \   0000006C   1F19               ADC     R17, R25
   \   0000006E   1F2A               ADC     R18, R26
   \   00000070   1F3A               ADC     R19, R26
   \   00000072   E0E8               LDI     R30, 8
   \   00000074   ........           JMP     ?EPILOGUE_B8_L09
    230          }
    231          //========================================================================

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
       0      2  clr_num_str_buf
       0      2  clr_tmp_num_str_buf
       4      2  int_to_str
                   4 2 -> clr_num_str_buf
       4      2  long_to_str
                   4 2 -> clr_num_str_buf
       4      2  str_to_int
       8      2  str_to_long


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      16  ?Subroutine0
       8  ?Subroutine1
       4  ?Subroutine2
       6  ?Subroutine3
       4  clr_num_str_buf
       6  clr_tmp_num_str_buf
      74  int_to_str
     114  long_to_str
      11  num_str_buf
      62  str_to_int
     120  str_to_long
       8  tab_10_16
      36  tab_10_32
      11  tmp_num_str_buf
       6  -- Other

 
 414 bytes in segment CODE
   6 bytes in segment INITTAB
  44 bytes in segment NEAR_F
  22 bytes in segment NEAR_Z
 
 458 bytes of CODE memory (+ 6 bytes shared)
  22 bytes of DATA memory

Errors: none
Warnings: none

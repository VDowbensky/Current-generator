//========================================================================
#include "bcd.h"
//========================================================================

//========================================================================
char num_str_buf [11];
char tmp_num_str_buf [11];
//========================================================================

//========================================================================
void clr_tmp_num_str_buf (void)
{
   char *ptr = tmp_num_str_buf;
   u08 cnt = 10;

   while (cnt)
   {
      *ptr++ = ' ';
      cnt--;
   }
   *ptr = 0;
}
//========================================================================

//========================================================================
void clr_num_str_buf (void)
{
   char *ptr = num_str_buf;
   u08 cnt = 10;

   while (cnt)
   {
      *ptr++ = ' ';
      cnt--;
   }
   *ptr = 0;
}
//========================================================================

//========================================================================
u16 __flash tab_10_16 [] =
{
   10000U,
   1000U,
   100U,
   10U,
};
//------------------------------------------------------------------------
void int_to_str (u16 value)
{
   clr_num_str_buf ();

   char *ptr = num_str_buf + 5;

   u16 a;

   u08 flags = 0;
   u08 cnt_1;
   u08 cnt_2;

   u16 __flash *ptr_f = tab_10_16;

   cnt_1 = 4;

   while (cnt_1)
   {
      a = *ptr_f;
      cnt_2 = 0;

      while (value >= a)
      {
         value -= a;
         cnt_2++;
      }

      if (!(flags & (1<<0)))
      {
         if (cnt_2 == 0)
         {
            *ptr++ = ' '; // Гашение незначащих нулей.
         }
         else
         {
            *ptr++ = (cnt_2 | 0x30);
            set_bit (flags, 0);
         }
      }
      else
      {
         *ptr++ = (cnt_2 | 0x30);
      }

      ptr_f++;
      cnt_1--;
   }
   *ptr++ = (value | 0x30);
   *ptr = 0;
}
//========================================================================

//========================================================================
// Я пока в раздумьях, на какой реакции остановиться, если в строке нет чисел.
// Можно сделать так: u16, u08 dec_hex_u16 (void). u08 0 - ошибка. 1 - ошибок нет.
// Также можно сделать следующее. Если разрядность строки больше u16 - ошибка.

u16 str_to_int (void)
{
   char *ptr_num = tmp_num_str_buf + 5;
   u16 __flash *ptr_tab_10 = tab_10_16;
   u16 a;
   u08 cnt = 0;
   u16 tmp_value = 0;

   while (cnt < 4)
   {
      if ((*ptr_num > 0x30) && (*ptr_num < 0x3A))
      {
         a = (*ptr_num - 0x30);

         while (a)
         {
            tmp_value += *ptr_tab_10;
            a--;
         }
      }
      *ptr_num++;
      ptr_tab_10++;
      cnt++;
   }
      return tmp_value += (*ptr_num - 0x30);
}
//========================================================================

//========================================================================
u32 __flash tab_10_32 [] =
{
   1000000000U,
   100000000U,
   10000000U,
   1000000U,
   100000U,
   10000U,
   1000U,
   100U,
   10U,
};
//------------------------------------------------------------------------
void long_to_str (u32 value)
{
   clr_num_str_buf ();

   char *ptr = num_str_buf;

   u32 a;

   u08 flags = 0;
   u08 cnt_1;
   u08 cnt_2;

   u32 __flash *ptr_f = tab_10_32;

   cnt_1 = 9;

   while (cnt_1)
   {
      a = *ptr_f;
      cnt_2 = 0;

      while (value >=a)
      {
         value -= a;
         cnt_2++;
      }

      if (!(flags & (1<<0)))
      {
         if (cnt_2 == 0)
         {
            *ptr++ = ' '; // Гашение незначащих нулей.
         }
         else
         {
            *ptr++ = (cnt_2 | 0x30);
            set_bit (flags, 0);
         }
      }
      else
      {
         *ptr++ = (cnt_2 | 0x30);
      }

      ptr_f++;
      cnt_1--;
   }
   *ptr++ = (value | 0x30);
   *ptr = 0;
}
//========================================================================

//========================================================================
// Я пока в раздумьях, на какой реакции остановиться, если в строке нет чисел.
// Можно сделать так: u32, u08 dec_hex_u32 (void). u08 0 - ошибка. 1 - ошибок нет.
// Также можно сделать следующее. Если разрядность строки больше u32 - ошибка.

u32 str_to_long (void)
{
   char *ptr_num = tmp_num_str_buf;
   u32 __flash *ptr_tab_10 = tab_10_32;
   u32 a;
   u08 cnt = 0;
   u32 tmp_value = 0;

   while (cnt < 9)
   {
      if ((*ptr_num > 0x30) && (*ptr_num < 0x3A))
      {
         a = (*ptr_num - 0x30);

         while (a)
         {
            tmp_value += *ptr_tab_10;
            a--;
         }
      }
      *ptr_num++;
      ptr_tab_10++;
      cnt++;
   }
      return tmp_value += (*ptr_num - 0x30);
}
//========================================================================